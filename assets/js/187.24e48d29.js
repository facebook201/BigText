(window.webpackJsonp=window.webpackJsonp||[]).push([[187],{803:function(t,s,a){"use strict";a.r(s);var e=a(30),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1、软件包管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、软件包管理"}},[t._v("#")]),t._v(" 1、软件包管理")]),t._v(" "),s("p",[t._v('​\t\t指的是系统中一种安装和维护软件的方法。两大包管理技术阵营——Debian的".deb"和红帽的“.rpm”。')]),t._v(" "),s("p",[t._v("​\t\t"),s("strong",[t._v("包文件："),s("strong",[t._v("在包管理系统中软件的基本单元是")]),t._v("包文件")]),t._v("。包文件是一个构成软件包的文件压缩集合。一个软件包 可能由大量程序以及支持这些程序的数据文件组成。。除了安装文件之外，软件包文件也包括 关于这个包的元数据，如软件包及其内容的文本说明。另外，许多软件包还包括预安装和安装后脚本， 这些脚本用来在软件安装之前和之后执行配置任务。")]),t._v(" "),s("p",[t._v("​\t\t"),s("strong",[t._v("资源库：")]),t._v(" 在软件开发不同周期内存放不同性质（测试、开发）的软件包的库。")]),t._v(" "),s("p",[s("strong",[t._v("1、上层和底层软件包工具")])]),t._v(" "),s("p",[t._v('​\t\t软件包管理系统通常由两种工具类型组成：底层工具用来处理这些任务，比方说安装和删除软件包文件， 和上层工具，完成元数据搜索和依赖解析。"package_name" 这个术语是指软件包实际名称，而不是指"package_file"，它是包含在软件包中的文件名。')]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("发行版")]),t._v(" "),s("th",[t._v("底层工具")]),t._v(" "),s("th",[t._v("上层工具")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Debian-Style")]),t._v(" "),s("td",[t._v("dpkg")]),t._v(" "),s("td",[t._v("apt-get,aptitude")])]),t._v(" "),s("tr",[s("td",[t._v("Fedora,Red Hat Enterprise Linux,Centos")]),t._v(" "),s("td",[t._v("rpm")]),t._v(" "),s("td",[t._v("yum")])])])]),t._v(" "),s("p",[s("strong",[t._v("2、查找资源库中的软件包")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("风格")]),t._v(" "),s("th",[t._v("命令")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("Debian")]),t._v(" "),s("td",[t._v("apt-get update；apt-cache search search_string")])]),t._v(" "),s("tr",[s("td",[t._v("Red Hat")]),t._v(" "),s("td",[t._v("yum search search_string")])])])]),t._v(" "),s("p",[s("strong",[t._v("2、从资源库中安装一个软件包、卸载软件、更新软件")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("功能")]),t._v(" "),s("th",[t._v("Debian")]),t._v(" "),s("th",[t._v("Red Hat")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("安装")]),t._v(" "),s("td",[t._v("apt-get update;apt-get install package_name")]),t._v(" "),s("td",[t._v("yum install package_name")])]),t._v(" "),s("tr",[s("td",[t._v("卸载")]),t._v(" "),s("td",[t._v("apt-get remove package_name")]),t._v(" "),s("td",[t._v("yum erase package_name")])]),t._v(" "),s("tr",[s("td",[t._v("更新")]),t._v(" "),s("td",[t._v("apt-get update；apt-get upgrade")]),t._v(" "),s("td",[t._v("yum update")])]),t._v(" "),s("tr",[s("td",[t._v("显示所安转软件包的信息")]),t._v(" "),s("td",[t._v("apt-cache show package_name")]),t._v(" "),s("td",[t._v("yum info package_name")])])])]),t._v(" "),s("p",[s("strong",[t._v("3、通过软件包文件来安装软件、经过软件包文件来升级软件")])]),t._v(" "),s("p",[t._v("​\t\t从某处而不是先从资源库中下载软件包文件，可以直接使用底层工具来直接安装它们。底层软件包安装命令如下所示。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("功能")]),t._v(" "),s("th",[t._v("Debian")]),t._v(" "),s("th",[t._v("Red Hat")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("安装软件")]),t._v(" "),s("td",[t._v("dpkg --install package_file")]),t._v(" "),s("td",[t._v("rpm -i package_file")])]),t._v(" "),s("tr",[s("td",[t._v("更新软件")]),t._v(" "),s("td",[t._v("dpkg --install package_file")]),t._v(" "),s("td",[t._v("rpm -U package_file")])]),t._v(" "),s("tr",[s("td",[t._v("确认是否安装了软件包")]),t._v(" "),s("td",[t._v("dpkg --status package_name")]),t._v(" "),s("td",[t._v("rpm -q package_name")])]),t._v(" "),s("tr",[s("td",[t._v("确定安装了那个文件的软件包")]),t._v(" "),s("td",[t._v("dpkg --search file_name")]),t._v(" "),s("td",[t._v("rpm -qf file_name")])]),t._v(" "),s("tr",[s("td",[t._v("查看安装了那些软件包")]),t._v(" "),s("td",[t._v("dpkg --list")]),t._v(" "),s("td",[t._v("rpm -qa")])])])]),t._v(" "),s("h3",{attrs:{id:"_2、网络系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、网络系统"}},[t._v("#")]),t._v(" 2、网络系统")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("• ping "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 发送 "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ICMP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ECHO_REQUEST")]),t._v(" 软件包到网络主机\n• netstat "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 打印网络连接，路由表，接口统计数据，伪装连接，和多路广播成员\n• wget "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 非交互式网络下载器\n• ssh "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" OpenSSH "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SSH")]),t._v(" 客户端（远程登录程序）\n")])])]),s("p",[s("strong",[t._v("1、ping")])]),t._v(" "),s("p",[t._v("​\t\t命令发送一个特殊的网络数据包，叫做 IMCP ECHO_REQUEST，到一台指定的主机。大多数接收这个包的网络设备将会回复它，来允许网络连接验证。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("ping 域名"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("IP")]),t._v("地址\n")])])]),s("p",[s("strong",[t._v("2、netstat")])]),t._v(" "),s("p",[t._v("​\t\t该程序被用来检查各种各样的网络设置和统计数据。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("netstat "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("ie"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//查看系统中的网络接口：")]),t._v("\nnetstat "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("r "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//会显示内核的网络路由表")]),t._v("\n")])])]),s("p",[s("strong",[t._v("3、wget")])]),t._v(" "),s("p",[t._v("​\t\twget可以从网络和FTP网站上都能下载数据。不止能下载单个文件，多个文件，甚至整个网站都能下载。wget的许多选项允许wget递归的下载，在后台下载文件（退出后仍在下载）。")]),t._v(" "),s("p",[s("strong",[t._v("4、ssh")])]),t._v(" "),s("p",[t._v("​\t\tssh（Secure Shell）解决了与远端主机安全交流的问题。首先，它要验证远端主机是否为它所知道的那台主机（阻止了“中间人”的攻击）。其次，它加密了本地和远程主机之间所有的通讯信息。")]),t._v(" "),s("p",[t._v("​\t\tssh又两部分组成。ssh服务器在远程主机上运行，在端口22上监听将要到来的链接。ssh客户端用在本地系统中，用来与远程服务器通信。")]),t._v(" "),s("p",[t._v("​\t\t当你通过 SSH 协议与远端主机建立连接的时候，其中发生的事就是在"),s("strong",[t._v("本地与远端系统之间 创建了一条加密通道")]),t._v("。通常，这条通道被用来把在本地系统中输入的命令安全地传输到远端系统， 同样地，再把执行结果安全地发送回来。")]),t._v(" "),s("p",[t._v("​\t\t大多数 Linux 发行版自带一个提供 SSH 功能的软件包，叫做 "),s("strong",[t._v("OpenSSH")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("ssh 用户名@ip地址 "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用ssh登录服务器")]),t._v("\n")])])]),s("p",[s("strong",[t._v("5、scp")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("、从远程系统复制文档到本地系统\nscp 用户名@ip"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("、将文件从本地复制到linux服务器\nscp 文件 用户名@ip"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("文件名或者")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("表示就用本地文件名称"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("、将文件夹从本地复制到linux服务器\nscp "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("r 文件夹 用户名@ip"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("文件名或者")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("表示就用本地文件名称"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("h3",{attrs:{id:"_3、查找文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、查找文件"}},[t._v("#")]),t._v(" 3、查找文件")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("• locate – 通过名字来查找文件\n• find – 在目录层次结构中搜索文件\n我们也将看一个经常与文件搜索命令一起使用的命令，它用来处理搜索到的文件列表：\n• xargs – 从标准输入生成和执行命令行\n另外，我们将介绍两个命令来协助我们探索：\n• touch – 更改文件时间\n• stat – 显示文件或文件系统状态，展示系统对某个文件及其属性所知道的所有信息\n")])])]),s("p",[s("strong",[t._v("1、locate-查找文件")])]),t._v(" "),s("p",[t._v("​\t\t locate 程序支持基本的（--regexp 选项）和扩展的（--regex 选项）正则表达式")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("locate 文件名称"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// locate只能依据文件名来查找文件")]),t._v("\nlocate "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v("regex "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'bin/(gz|zip)'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//模糊匹配bin/zip和bin/gz文件")]),t._v("\n")])])]),s("p",[s("strong",[t._v("2、find-查找文件的复杂方式")])]),t._v(" "),s("p",[t._v("​\t\tfind 程序能基于各种各样的属性， 搜索一个给定目录（以及它的子目录），来查找文件。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("find "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//输出家目录列表")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type d"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//只搜索目录")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//只搜索普通文件")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\\*.jpg"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("size "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v("1M "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//查找所有文件名匹配 通配符模式“*.JPG”和文件大小大于（-表示小于，没有符号意味着精确匹配）1M 的文件")]),t._v("\n")])])]),s("p",[t._v("​\t\t"),s("code",[t._v("type")]),t._v("的参数有b(块设备文件)、c(字符设备文件)、d(目录)、f(普通文件)、l(符号链接)五种类型。")]),t._v(" "),s("p",[t._v("​\t\t"),s("code",[t._v("size")]),t._v("的参数有b(512个字节快，默认值)、c(字节)、w(两个字节的字)、k(1024个单位字节)、M(兆字节)、G(千兆字节)")]),t._v(" "),s("p",[t._v('​\t\tfind 命令支持大量不同的测试条件。下表是列出了一些常见的测试条件。请注意，在需要数值参数的 情况下，可以应用以上讨论的“+”和"-"符号表示法：')]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-cmin")]),t._v(" n \t\t匹配的文件和目录的内容或属性最后修改时间正好在 n 分钟之前。 指定少于 n 分钟 之前，使用 -\t\t\t\t\tn，指定多于 n 分钟之前，使用 +n。\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-cnewer")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("file")]),t._v(" \t匹配的文件和目录的内容或属性最后修改时间早于那些文件。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-ctime")]),t._v(" n \t\t匹配的文件和目录的内容和属性最后修改时间在 n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("*24小时之前。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-empty")]),t._v(" \t\t\t匹配空文件和目录。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-group")]),t._v(" name \t匹配的文件和目录属于一个组。组可以用组名或组 ID 来表示。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-iname")]),t._v(" pattern \t就像-name 测试条件，但是不区分大小写。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-inum")]),t._v(" n \t\t匹配的文件的 inode 号是 n。这对于找到某个特殊 inode 的所有硬链接很有帮助。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-mmin")]),t._v(" n \t\t匹配的文件或目录的内容被修改于 n 分钟之前。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-mtime")]),t._v(" n \t\t匹配的文件或目录的内容被修改于 n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("\\")]),t._v("*24小时之前\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-name")]),t._v(" pattern \t用指定的通配符模式匹配的文件和目录。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-newer")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("file")]),t._v(" \t匹配的文件和目录的内容早于指定的文件。当编写 shell 脚本，做文件备份时，非常有帮助。 每\t\t\t\t\t次你制作一个备份，更新文件（比如说日志），然后使用 "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("find")]),t._v(" 命令来 决定自从上次更新，哪\t\t\t\t\t一个文件已经更改了。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-nouser")]),t._v(" \t\t匹配的文件和目录不属于一个有效用户。这可以用来查找属于删除帐户的文件或监测攻击行为。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-nogroup")]),t._v(" \t\t匹配的文件和目录不属于一个有效的组。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-perm")]),t._v(" mode \t\t匹配的文件和目录的权限已经设置为指定的 mode。mode 可以用 八进制或符号表 示法。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-samefile")]),t._v(" name \t相似于-inum 测试条件。匹配和文件 name 享有同样 inode 号的文件。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-size")]),t._v(" n \t\t匹配的文件大小为 n。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-type")]),t._v(" c \t\t匹配的文件类型是 c。 c可以是"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("文件"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("、d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("目录"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-user")]),t._v(" name \t\t匹配的文件或目录属于某个用户。这个用户可以通过用户名或用户 ID 来表示。\n")])])]),s("p",[t._v("find文件类型")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("b\t\t块设备文件\nc\t\t字符设备文件\nd\t\t目录\nf\t\t普通文件\nl\t\t符号链接\n")])])]),s("ul",[s("li",[s("strong",[t._v("逻辑操作符")])])]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-and")]),t._v("\t\t如果操作符两边的测试条件都是真，则匹配。可以简写为"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-a")]),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-or")]),t._v("\t\t\t操作符两边的任一个测试条件为真，则匹配。可以简写为"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-o")]),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-not")]),t._v("\t\t操作符后面的测试条件为真，则匹配。简写为"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\t\t\t将测试条件和操作符组合起来行程更大的表达式。\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//对于文件，我们定义正确权限为0600， 目录则为0711。测试具有“不正确”权限的文件表达式为： ")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" \\"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("not "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("perm "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0600")]),t._v(" \\"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("or \\"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("not "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("perm "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0700")]),t._v(" \\"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//表示( file with bad perms ) -or ( directory with bad perms )。")]),t._v("\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("expr1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("operator expr2\n")])])]),s("p",[t._v("在所有情况下，总会执行表达式 expr1；然而由操作符来决定是否执行表达式 expr2。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("预定义的操作")])])]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-delete")]),t._v("\t\t删除当前匹配的文件\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-ls")]),t._v("\t\t\t对匹配单位文件执行等同的"),s("span",{pre:!0,attrs:{class:"token variable"}},[s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ls")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-dils")]),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("`")])]),t._v("命令。并将结果发送到标准输出\n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-print")]),t._v("\t\t把匹配文件的全路径名输送到标准输出。如果没有指定其它操作，这是 默认操作。 \n"),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-quit")]),t._v(" \t\t一旦找到一个匹配，退出。\n")])])]),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//用户家目录（和它的子目录）下搜索每个以.BAK 结尾的文件名。当找到后，就删除它们。")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'*.BAK'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),t._v("\n")])])]),s("p",[s("strong",[t._v("4、用户自定义行为")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("exec command "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// command 就是指一个命令的名字，{}是当前路径名的符号表示，分号是要求的界定符表明命令结束。")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo*'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("ok ls "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{}'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("';'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//删除搜索到的文件，但是需要按确认键")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo*'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("exec ls "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{}'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("';'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//删除搜索到的文件")]),t._v("\n")])])]),s("p",[s("strong",[t._v("5、xargs")])]),t._v(" "),s("p",[t._v("​\t\t xargs 命令会执行一个有趣的函数。它从标准输入接受输入，并把"),s("strong",[t._v("输入转换为一个特定命令的参数列表")]),t._v("。从而提高执行效率。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//find 命令的输出被管道到 xargs 命令，反过来，xargs 会为 ls 命令构建参数列表，然后执行 ls 命令。")]),t._v("\nfind "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'foo\\*'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("print "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" xargs ls "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//找出playground文件夹下所有的名称为'file-A'的文件")]),t._v("\nfind playground "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("type f "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'file-A'")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"_4、归档和备份"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、归档和备份"}},[t._v("#")]),t._v(" 4、归档和备份")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("• "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gzip")]),t._v(" – 压缩或者展开文件\n• "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bzip2")]),t._v(" – 块排序文件压缩器\n归档程序：\n• "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tar")]),t._v(" – 磁带打包工具\n• "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("zip")]),t._v(" – 打包和压缩文件\n还有文件同步程序：\n• "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("rsync")]),t._v(" – 同步远端文件和目\n")])])]),s("p",[s("strong",[t._v("1、压缩文件")])]),t._v(" "),s("p",[t._v("​\t\t压缩算法（数学技巧被用来执行压缩任务）分为两大类，"),s("strong",[t._v("无损压缩和有损压缩")]),t._v("。无损压缩保留了 原始文件的所有数据。这意味着，当还原一个压缩文件的时候，还原的文件与原文件一模一样。 而另一方面，有损压缩，执行压缩操作时会删除数据，允许更大的压缩。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("gzip。这个 gzip 程序被用来压缩一个或多个文件。当执行 gzip 命令时，则原始文件的压缩版会替代原始文件。 相对应的 gunzip 程序被用来把压缩文件复原为没有被压缩的版本。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("gzip "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 压缩")]),t._v("\ngunzip "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("gz "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//解压，解压时不用写.gz后缀也可以")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//浏览压缩文件的内容")]),t._v("\ngunzip "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("c foo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" less\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//浏览压缩文件的内容")]),t._v("\nzcat foo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("gz "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" less\n")])])]),s("p",[t._v("gzip的选项：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("选项")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-c")]),t._v(" "),s("td",[t._v("把输出写入到标准输出，并且保留原始文件。也有可能用--stdout 和--to-stdout 选项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-d")]),t._v(" "),s("td",[t._v("解压缩。正如 gunzip 命令一样。也可以用--decompress 或者--uncompress 选项来指定.")])]),t._v(" "),s("tr",[s("td",[t._v("-f")]),t._v(" "),s("td",[t._v("强制压缩，即使原始文件的压缩文件已经存在了，也要执行。也可以用--force 选 项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-h")]),t._v(" "),s("td",[t._v("显示用法信息。也可用--help 选项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-l")]),t._v(" "),s("td",[t._v("列出每个被压缩文件的压缩数据。也可用--list 选项。")])]),t._v(" "),s("tr",[s("td",[t._v("-r")]),t._v(" "),s("td",[t._v("若命令的一个或多个参数是目录，则递归地压缩目录中的文件。也可用--recursiv e 选项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-t")]),t._v(" "),s("td",[t._v("测试压缩文件的完整性。也可用--test 选项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-v")]),t._v(" "),s("td",[t._v("显示压缩过程中的信息。也可用--verbose 选项来指定。")])]),t._v(" "),s("tr",[s("td",[t._v("-number")]),t._v(" "),s("td",[t._v("设置压缩指数。number 是一个在1（最快，最小压缩）到9（最慢，最大压缩）之 间的整数。 数值1和9也可以各自用--fast 和--best 选项来表示。默认值是整数 6。")])])])])]),t._v(" "),s("li",[s("p",[t._v("zip")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("zip options zipfile file"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v("\nzip "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("r playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zip playground  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//压缩文件")]),t._v("\nunzip playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zip\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//解压")]),t._v("\nunzip "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zip playground"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("dir"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("87")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("file"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Z")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//选择性的解压文件")]),t._v("\nls "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("etc"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" zip ls"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("etc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zip "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('//最后面的横杠为"标准输入作为输入文件"')]),t._v("\n")])])])])]),t._v(" "),s("p",[s("strong",[t._v("2、归档文件")])]),t._v(" "),s("p",[t._v("​\t\t归档就是收集许多文件，并把它们捆绑成一个大文件的过程。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("tar——tape archive的简称。到扩展名为 .tar 或者 .tgz 的文件，它们各自表示“普通” 的 tar 包和被 gzip 程序压缩过的 tar包。一个 tar 包可以由一组独立的文件，一个或者多个目录，或者 两者混合体组成。"),s("strong",[t._v("必须先指定模式，然后再指定选项。")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("tar mode"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("options"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" pathname"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//mode表示操作模式")]),t._v("\ntar cf playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tar playground "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将playground目录创建为playground.tar包 c是模式，f是选项")]),t._v("\ntar xf "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tar   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将归档文件抽取出来")]),t._v("\ntar xf archive"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tar pathname"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("...")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//通过指定路径名来抽取指定的文件")]),t._v("\nfind playground "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'file-A'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("exec tar rf playground"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("tar "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'{}'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'+'")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//们使用 find 命令来匹配 playground 目录中所有名为 file-A 的文件，然后使用-exec 行为，来 唤醒带有追加模式（r）的 tar 命令，把匹配的文件添加到归档文件 playground.tar 里面。")]),t._v("\n")])])]),s("p",[t._v("tar有以下"),s("strong",[t._v("操作模式")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("模式")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("c")]),t._v(" "),s("td",[t._v("为文件和／或目录列表创建归档文件。")])]),t._v(" "),s("tr",[s("td",[t._v("x")]),t._v(" "),s("td",[t._v("抽取归档文件。")])]),t._v(" "),s("tr",[s("td",[t._v("r")]),t._v(" "),s("td",[t._v("追加具体的路径到归档文件的末尾。")])]),t._v(" "),s("tr",[s("td",[t._v("t")]),t._v(" "),s("td",[t._v("列出归档文件的内容。")])])])]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tar")]),t._v(" xzf diction.tar.gz // 抽取"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("-z"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("gzip压缩过的文件\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tar")]),t._v(" czvf test.tar.gz "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("test")]),t._v(" //将test文件压缩为test.tar.gz\n")])])])])]),t._v(" "),s("h3",{attrs:{id:"_5、文本处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、文本处理"}},[t._v("#")]),t._v(" 5、文本处理")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("• sort – 给文本行排序\n• uniq – 报告或者省略重复行\n• cut – 从每行中删除文本区域\n• paste – 合并文件文本行\n• join – 基于某个共享字段来联合两个文件的文本行\n• comm – 逐行比较两个有序的文件\n• diff – 逐行比较文件\n• patch – 给原始文件打补丁\n• tr – 翻译或删除字符\n• sed – 用于筛选和转换文本的流编辑器\n• aspell – 交互式拼写检查器\n")])])]),s("p",[s("strong",[t._v("1、sort")])]),t._v(" "),s("p",[t._v("​\t\tsort 程序对标准输入的内容，或命令行中指定的一个或多个文件进行排序，然后把排序 结果发送到标准输出。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("sort foo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对foo.txt的文件内容进行排序")]),t._v("\nsort file1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt file2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt file3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" final_sorted_list"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将文件排序并输入到另一个文件中")]),t._v("\nls "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("l "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("usr"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("bin "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" sort "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("nr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("k "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" head "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//忽略 ls 程序能按照文件大小对输出结果进行排序")]),t._v("\nsort "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("t "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("':'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("k "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("etc"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("passwd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" head  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//按':'为分隔符，按照第7个字段进行排序")]),t._v("\n")])])]),s("p",[t._v("sort 程序有几个有趣的选项。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("选项")]),t._v(" "),s("th",[t._v("长选项")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-b")]),t._v(" "),s("td",[t._v("--ignore-leading-bla nks")]),t._v(" "),s("td",[t._v("默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项 导致 sort 程序忽略 每行开头的空格，从第一个非空白字符开始排 序。")])]),t._v(" "),s("tr",[s("td",[t._v("-f")]),t._v(" "),s("td",[t._v("--ignore-case")]),t._v(" "),s("td",[t._v("让排序不区分大小写。")])]),t._v(" "),s("tr",[s("td",[t._v("-n")]),t._v(" "),s("td",[t._v("--numeric-sort")]),t._v(" "),s("td",[t._v("基于字符串的长度来排序。使用此选项允许根据数字值执行排序，而 不是字母值。")])]),t._v(" "),s("tr",[s("td",[t._v("-r")]),t._v(" "),s("td",[t._v("--reverse")]),t._v(" "),s("td",[t._v("按相反顺序排序。结果按照降序排列，而不是升序。")])]),t._v(" "),s("tr",[s("td",[t._v("-k")]),t._v(" "),s("td",[t._v("--key=field1[,field2]")]),t._v(" "),s("td",[t._v("对从 field1到 field2之间的字符排序，而不是整个文本行。看下面的 讨论。")])]),t._v(" "),s("tr",[s("td",[t._v("-m")]),t._v(" "),s("td",[t._v("--merge")]),t._v(" "),s("td",[t._v("把每个参数看作是一个预先排好序的文件。把多个文件合并成一个排 好序的文件，而没有执行额外的排序。")])]),t._v(" "),s("tr",[s("td",[t._v("-o")]),t._v(" "),s("td",[t._v("--output=file")]),t._v(" "),s("td",[t._v("把排好序的输出结果发送到文件，而不是标准输出。")])]),t._v(" "),s("tr",[s("td",[t._v("-t")]),t._v(" "),s("td",[t._v("--field-separator=ch ar")]),t._v(" "),s("td",[t._v("定义域分隔字符。默认情况下，域由空格或制表符分隔。")])])])]),t._v(" "),s("p",[s("strong",[t._v("2、切片和切块")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("cut")])])]),t._v(" "),s("p",[t._v("​\t\t cut 程序被用来从文本行中抽取文本，并把其输出到标准输出。它能够接受多个文件参数或者标准输入。")]),t._v(" "),s("p",[t._v("​\t\tcut程序主要有以下选项：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("选项")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-c char_list")]),t._v(" "),s("td",[t._v("从文本行中抽取由 char_list 定义的文本。这个列表可能由一个或多个逗号分隔开的数值区间组成。")])]),t._v(" "),s("tr",[s("td",[t._v("-f field_list")]),t._v(" "),s("td",[t._v("从文本行中抽取一个或多个由 field_list 定义的字段。这个列表可能包括一个或多个字段，或由逗号分隔开的字段区间。")])]),t._v(" "),s("tr",[s("td",[t._v("-d delim_char")]),t._v(" "),s("td",[t._v("当指定-f 选项之后，使用 delim_char 做为字段分隔符。默认情况下， 字段之间必 须由单个 tab 字符分隔开。")])]),t._v(" "),s("tr",[s("td",[t._v("--complement")]),t._v(" "),s("td",[t._v("抽取整个文本行，除了那些由-c 和／或-f 选项指定的文本。")])])])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将distros.txt每行，按tab键分割，然后取分割后每行的第3个数据")]),t._v("\ncut "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("f "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" distros"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt  \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//从第3个数据中，抽取7-10位置的字符")]),t._v("\ncut "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("f "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" distros"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" cut "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("c "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指定冒号做为字段分隔符。并只取前1个数据")]),t._v("\ncut "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("d "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("':'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("f "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("etc"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("passwd "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" head \n")])])]),s("ul",[s("li",[s("p",[s("strong",[t._v("paste")])]),t._v(" "),s("p",[t._v("​\t\tpaste 命令的功能正好与 cut 相反。它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。 它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准出。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将distros-versions.txt文件中对应行的数据distros-dates.txt对应行的后面")]),t._v("\npaste distros"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("dates"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt distros"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("versions"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt \n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("join")])]),t._v(" "),s("p",[t._v("​\t\t把来自于多个基于共享 关键域的文件的数据结合起来。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("join distros"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("names"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt distros"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("vernums"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt \n")])])])])]),t._v(" "),s("p",[s("strong",[t._v("3、比较文本")])]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("comm")])]),t._v(" "),s("p",[t._v("comm 程序会比较两个文本文件，并且会显示每个文件特有的文本行和共有的文把行。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("comm "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//比较1.txt和2.txt的差异 ，会显示三列数据，1列共有的，2列各自独有的")]),t._v("\ncomm "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" file1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt file2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//只显示共有列，隐藏独有列")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("diff")])]),t._v(" "),s("p",[t._v("diff 程序被用来监测文件之间的差异。最流行的两种格式是上下文模式和统一模式。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//上下文模式")]),t._v("\ndiff "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("c file1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt file2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//统一模式")]),t._v("\ndiff "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("u file1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt file2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n")])])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("patch")])]),t._v(" "),s("p",[t._v("​\t\t这个 patch 程序被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来 把较老的文件版本转变为较新的文件版本。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//创建diff文件")]),t._v("\ndiff "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("u "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" patch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//把旧文件修补成新文件。")]),t._v("\npatch patch"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("txt\n")])])])])]),t._v(" "),s("p",[s("strong",[t._v("4、运行时编辑")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("tr")]),t._v(" "),s("p",[t._v("tr 程序被用来更改字符。我们可以把它看作是一种基于字符的查找和替换操作。 换字是一种把字符从一个字母转换为另一个字母的过程。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将小写转换成大写")]),t._v("\necho "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lowercase letters"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" tr a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("z "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Z")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//将小写字母转换成大写A")]),t._v("\necho "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"lowercase letters"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" tr "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("lower"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("A")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//删除相邻重复的字符")]),t._v("\necho "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aaabbbccc"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" tr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("s ab \n")])])])]),t._v(" "),s("li",[s("p",[t._v("sed")]),t._v(" "),s("p",[t._v("​\t\t名字 sed 是 "),s("code",[t._v("stream editor")]),t._v("（"),s("strong",[t._v("流编辑器")]),t._v("）的简称。它对文本流进行编辑，要不是一系列指定的文件， 要不就是标准输入。")]),t._v(" "),s("p",[t._v("​\t\tsed的命令开始与单个字符。替换命令由字母s来代表，后面跟着查找和替换字符串，分隔符的选择是随意的，一般用斜杆字符。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"front"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"s/front/back/"')]),t._v(" //用back替换front类似于替换查找操作\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"front"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2s/front/back/'")]),t._v(" //给命令添加地址2，对输入流的第2行进行替换操作\n")])])]),s("p",[t._v("地址有很多方式来表达，下面是常用的sed地址表示法：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("地址")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("n")]),t._v(" "),s("td",[t._v("行号，n 是一个正整数。")])]),t._v(" "),s("tr",[s("td",[t._v("$")]),t._v(" "),s("td",[t._v("最后一行。")])]),t._v(" "),s("tr",[s("td",[t._v("/regexp/")]),t._v(" "),s("td",[t._v("所有匹配一个 POSIX 基本正则表达式的文本行。注意正则表达式通过 斜杠字符界 定。选择性地，这个正则表达式可能由一个备用字符界定，通过\\cregexpc 来 指定 表达式，这里 c 就是一个备用的字符。")])]),t._v(" "),s("tr",[s("td",[t._v("addr1,addr2")]),t._v(" "),s("td",[t._v("从 addr1 到 addr2 范围内的文本行，包含地址 addr2 在内。地址可能是上述任意 单独的地址形式。")])]),t._v(" "),s("tr",[s("td",[t._v("first~step")]),t._v(" "),s("td",[t._v("匹配由数字 first 代表的文本行，然后随后的每个在 step 间隔处的文本行。例如 1~2 是指每个位于偶数行号的文本行，5~5 则指第五行和之后每五行位置的文本 行。")])]),t._v(" "),s("tr",[s("td",[t._v("addr1,+n")]),t._v(" "),s("td",[t._v("匹配地址 addr1 和随后的 n 个文本行。")])]),t._v(" "),s("tr",[s("td",[t._v("addr!")]),t._v(" "),s("td",[t._v("匹配所有的文本行，除了 addr 之外，addr 可能是上述任意的地址形式。")])])])]),t._v(" "),s("p",[t._v("sed的基本编辑命令如下所示：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("命令")]),t._v(" "),s("th",[t._v("说明")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("=")]),t._v(" "),s("td",[t._v("输出当前的行号。")])]),t._v(" "),s("tr",[s("td",[t._v("a")]),t._v(" "),s("td",[s("strong",[t._v("在当前行之后追加文本。")])])]),t._v(" "),s("tr",[s("td",[t._v("d")]),t._v(" "),s("td",[t._v("删除当前行。")])]),t._v(" "),s("tr",[s("td",[t._v("i")]),t._v(" "),s("td",[s("strong",[t._v("在当前行之前插入文本。")])])]),t._v(" "),s("tr",[s("td",[t._v("p")]),t._v(" "),s("td",[t._v("打印当前行。默认情况下，sed 程序打印每一行，并且只是编辑文件中匹配 指定地 址的文本行。通过指定-n 选项，这个默认的行为能够被忽略。")])]),t._v(" "),s("tr",[s("td",[t._v("q")]),t._v(" "),s("td",[t._v("退出 sed，不再处理更多的文本行。如果不指定-n 选项，输出当前行。")])]),t._v(" "),s("tr",[s("td",[t._v("Q")]),t._v(" "),s("td",[t._v("退出 sed，不再处理更多的文本行。")])]),t._v(" "),s("tr",[s("td",[t._v("s/regexp/replacement/")]),t._v(" "),s("td",[t._v("只要找到一个 regexp 匹配项，就替换为 replacement 的内容。 replacement 可 能包括特殊字符 &，其等价于由 regexp 匹配的文本。另外， replacement 可能 包含序列 \\1到 \\9，其是 regexp 中相对应的子表达式的内容。在 replacement 末尾的斜杠之后，可以指定一个 可选的标志，来修改 s 命令的行为。")])]),t._v(" "),s("tr",[s("td",[t._v("y/set1/set2")]),t._v(" "),s("td",[t._v("执行字符转写操作，通过把 set1 中的字符转变为相对应的 set2 中的字符。 注意不 同于 tr 程序，sed 要求两个字符集合具有相同的长度。")])])])]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2019/12/30"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"s/\\//-/g"')]),t._v(" //将"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v("替换为"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-"')]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" test.txt "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"s/\\//-/g"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" replace.txt //将test.txt文件中的所有"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/"')]),t._v("都替换为"),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"-"')]),t._v("，并输出到replace.txt中\n")])])]),s("p",[t._v("使用"),s("code",[t._v("-f")]),t._v("选项，格式化文件。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("//使用distros.sed来格式化distros.txt中的代码\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-f")]),t._v(" distros.sed distros.txt \n//替换修改foo.txt文件中的相关字符串\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-i")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'s/lazy/laxy/; s/jumped/jimped/'")]),t._v(" foo.txt\n\n")])])])]),t._v(" "),s("li",[s("p",[t._v("aspell")]),t._v(" "),s("p",[t._v("​\t\t一款交互式的拼写检查器。它能够智能地检查各种类型的文本文件， 包括 HTML 文件，C/C++ 程序，电子邮件和其它种类的专业文本。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("aspell check textfile\n")])])]),s("p",[t._v("注意：一旦结束aspell操作，再用aspell检查不会再有任何效果了。除非你又修改了该文件。")])])]),t._v(" "),s("h3",{attrs:{id:"_6、格式化输出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、格式化输出"}},[t._v("#")]),t._v(" 6、格式化输出")]),t._v(" "),s("p",[s("strong",[t._v("1、nl")])]),t._v(" "),s("p",[t._v("​\t\t像cat一样，nl能够接受多个文件作为命令行参数，也能标准输出。 nl有一些常用的选项，相当于"),s("code",[t._v("cat -n")]),t._v("。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("选项")]),t._v(" "),s("th",[t._v("含义")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-b style")]),t._v(" "),s("td",[t._v("把 body 按被要求方式数行，可以是以下方式："),s("br"),t._v("a = 数所有行"),s("br"),t._v("t = 数非空行。这是默认设置。"),s("br"),t._v("n = 无"),s("br"),t._v("pregexp = 只数那些匹配了正则表达式的行")])]),t._v(" "),s("tr",[s("td",[t._v("-f style")]),t._v(" "),s("td",[t._v("将 footer 按被要求设置数。默认是无")])]),t._v(" "),s("tr",[s("td",[t._v("-h style")]),t._v(" "),s("td",[t._v("将 header 按被要求设置数。默认是无")])]),t._v(" "),s("tr",[s("td",[t._v("-i number")]),t._v(" "),s("td",[t._v("将页面增加量设置为数字。默认是1。")])]),t._v(" "),s("tr",[s("td",[t._v("-n format")]),t._v(" "),s("td",[t._v("设置数数的格式，格式可以是："),s("br"),t._v("ln = 左偏，没有前导零。"),s("br"),t._v("rn = 右偏，没有前导零。"),s("br"),t._v("rz = 右偏，有前导零。")])]),t._v(" "),s("tr",[s("td",[t._v("-p")]),t._v(" "),s("td",[t._v("不要在每一个逻辑页面的开始重设页面数。")])]),t._v(" "),s("tr",[s("td",[t._v("-s string")]),t._v(" "),s("td",[t._v("在每一个行的末尾加字符作分割符号。默认是单个的 tab。")])]),t._v(" "),s("tr",[s("td",[t._v("-v number")]),t._v(" "),s("td",[t._v("将每一个逻辑页面的第一行设置成数字。默认是1。")])]),t._v(" "),s("tr",[s("td",[t._v("-w width")]),t._v(" "),s("td",[t._v("将行数的宽度设置，默认是6。")])])])]),t._v(" "),s("p",[s("strong",[t._v("2、fold")])]),t._v(" "),s("p",[t._v("​\t\t像其他命令，fold 接受一个或多个文件及标准输入。显示文件行宽。跟"),s("code",[t._v("nl")]),t._v("的选项一样。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("//限制行宽为12个字符，-s表示会考虑单词边界，按单词为单位。不会拆分单词。\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"The quick brown fox jumped over the lazy dog."')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fold")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-w")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter variable"}},[t._v("-s")]),t._v("  \n")])])]),s("h3",{attrs:{id:"_7、编译程序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、编译程序"}},[t._v("#")]),t._v(" 7、编译程序")]),t._v(" "),s("p",[s("strong",[t._v("1、什么是编译？")])]),t._v(" "),s("p",[t._v("​\t\t编译就是把源码（一个由程序员编写的人类可读的程序描述）翻译成计算机处理器的母语的过程。但是"),s("code",[t._v("shell")]),t._v("脚本不需要编译，它是"),s("strong",[t._v("脚本或解释型语言")]),t._v("。脚本语言由一个叫做解释器的特殊程序执行。"),s("strong",[t._v("解释型程序执行起来要比编译程序慢很多")]),t._v("。这是因为每次解释型程序执行时，程序中每一条源码指令都需要翻译， 而一个编译程序，一条源码指令只翻译一次，翻译后的指令会永久地记录到最终的执行文件中。"),s("strong",[t._v("开发解释型程序 要比编译程序快速且容易。")])]),t._v(" "),s("p",[s("strong",[t._v("2、获取源码")])]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ftp")]),t._v(" ftp.gnu.org \n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v(" gnu/diction \nget diction-1.11.tar.gz \nbye \n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tar")]),t._v(" xzf dict-1.111.tar.gz\n")])])]),s("p",[s("strong",[t._v("2、解读源码")])]),t._v(" "),s("p",[s("strong",[t._v("构建程序")])]),t._v(" "),s("p",[t._v("大多数程序通过一个简单的，两个命令的序列构建：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("./configure \n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v(" \n")])])]),s("p",[s("code",[t._v("configure")]),t._v("程序是shell脚本，它的工作是为了分析程序建立环境。"),s("strong",[s("code",[t._v("configue")]),t._v("是为了检查是否安装了必要的外部工具和组件。")]),s("code",[t._v("./")]),t._v("表示当前工作目录。运行会会创建一些文件如"),s("code",[t._v("Makefile")]),t._v("。")]),t._v(" "),s("p",[s("code",[t._v("make")]),t._v("程序会把"),s("code",[t._v("makefile")]),t._v("作为输入，"),s("code",[t._v("makefile")]),t._v("描述了包括最终完成的程序的各组件之间的关系和依赖性。"),s("code",[t._v("make")]),t._v(" 只是构建 需要构建的部分，而不是简单地重新构建所有的内容。")]),t._v(" "),s("p",[s("strong",[t._v("安装程序")])]),t._v(" "),s("p",[t._v("​\t\t打包良好的源码经常包括一个特别的 make 目标文件，叫做 install。这个目标文件将在系统目录中安装最终的产品，以供使用。 通常，这个目录是 /usr/local/bin，为在本地所构建软件的传统安装位置。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v("\n")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);