<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>leetcode之树专题 | 前端WebGL</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/blog/assets/css/0.styles.3b23bb34.css" as="style"><link rel="preload" href="/blog/assets/js/app.cc3037ec.js" as="script"><link rel="preload" href="/blog/assets/js/2.918eef7d.js" as="script"><link rel="preload" href="/blog/assets/js/1.dd66940c.js" as="script"><link rel="preload" href="/blog/assets/js/37.8fc3cb59.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6453242c.js"><link rel="prefetch" href="/blog/assets/js/100.e56f3d4b.js"><link rel="prefetch" href="/blog/assets/js/101.11a32ed7.js"><link rel="prefetch" href="/blog/assets/js/102.31b9b62d.js"><link rel="prefetch" href="/blog/assets/js/103.a618ed3a.js"><link rel="prefetch" href="/blog/assets/js/104.9d42920c.js"><link rel="prefetch" href="/blog/assets/js/105.90d79e64.js"><link rel="prefetch" href="/blog/assets/js/106.5601a757.js"><link rel="prefetch" href="/blog/assets/js/107.9628605d.js"><link rel="prefetch" href="/blog/assets/js/108.b193a4ac.js"><link rel="prefetch" href="/blog/assets/js/109.3303cb7b.js"><link rel="prefetch" href="/blog/assets/js/11.08701c0e.js"><link rel="prefetch" href="/blog/assets/js/110.6089abf2.js"><link rel="prefetch" href="/blog/assets/js/111.0a7528f5.js"><link rel="prefetch" href="/blog/assets/js/112.57e4b5b3.js"><link rel="prefetch" href="/blog/assets/js/113.7bfdbc1a.js"><link rel="prefetch" href="/blog/assets/js/114.d333e2d0.js"><link rel="prefetch" href="/blog/assets/js/115.0973b0d5.js"><link rel="prefetch" href="/blog/assets/js/116.a1ba085a.js"><link rel="prefetch" href="/blog/assets/js/117.82a5557c.js"><link rel="prefetch" href="/blog/assets/js/118.56fde63f.js"><link rel="prefetch" href="/blog/assets/js/119.5bc218f8.js"><link rel="prefetch" href="/blog/assets/js/12.a6781cb2.js"><link rel="prefetch" href="/blog/assets/js/120.91c31cb1.js"><link rel="prefetch" href="/blog/assets/js/121.aabb64fb.js"><link rel="prefetch" href="/blog/assets/js/122.e6d658e0.js"><link rel="prefetch" href="/blog/assets/js/123.f77060d1.js"><link rel="prefetch" href="/blog/assets/js/124.6443d972.js"><link rel="prefetch" href="/blog/assets/js/125.fdba328e.js"><link rel="prefetch" href="/blog/assets/js/126.177144f0.js"><link rel="prefetch" href="/blog/assets/js/127.f6d59d43.js"><link rel="prefetch" href="/blog/assets/js/128.6ecab9e1.js"><link rel="prefetch" href="/blog/assets/js/129.ace967e4.js"><link rel="prefetch" href="/blog/assets/js/13.e0daf978.js"><link rel="prefetch" href="/blog/assets/js/130.4ba0fc24.js"><link rel="prefetch" href="/blog/assets/js/131.18ad428f.js"><link rel="prefetch" href="/blog/assets/js/132.6de70f31.js"><link rel="prefetch" href="/blog/assets/js/133.2c554e19.js"><link rel="prefetch" href="/blog/assets/js/134.641f862f.js"><link rel="prefetch" href="/blog/assets/js/135.d3ac6b54.js"><link rel="prefetch" href="/blog/assets/js/136.38cbd2d5.js"><link rel="prefetch" href="/blog/assets/js/137.2d816f5d.js"><link rel="prefetch" href="/blog/assets/js/138.2ded09ab.js"><link rel="prefetch" href="/blog/assets/js/139.7a498eab.js"><link rel="prefetch" href="/blog/assets/js/14.8f90954a.js"><link rel="prefetch" href="/blog/assets/js/140.87a17f7c.js"><link rel="prefetch" href="/blog/assets/js/141.8e389061.js"><link rel="prefetch" href="/blog/assets/js/142.a2539e36.js"><link rel="prefetch" href="/blog/assets/js/143.cce2facb.js"><link rel="prefetch" href="/blog/assets/js/144.499084a9.js"><link rel="prefetch" href="/blog/assets/js/145.d78d73b3.js"><link rel="prefetch" href="/blog/assets/js/146.1bd86ed8.js"><link rel="prefetch" href="/blog/assets/js/147.a40db09a.js"><link rel="prefetch" href="/blog/assets/js/148.0bee9963.js"><link rel="prefetch" href="/blog/assets/js/149.36cae260.js"><link rel="prefetch" href="/blog/assets/js/15.0382753a.js"><link rel="prefetch" href="/blog/assets/js/150.0a5f2e96.js"><link rel="prefetch" href="/blog/assets/js/151.04077552.js"><link rel="prefetch" href="/blog/assets/js/152.00161169.js"><link rel="prefetch" href="/blog/assets/js/153.4be9c720.js"><link rel="prefetch" href="/blog/assets/js/154.550525cd.js"><link rel="prefetch" href="/blog/assets/js/155.1df5780e.js"><link rel="prefetch" href="/blog/assets/js/156.b09cccc6.js"><link rel="prefetch" href="/blog/assets/js/157.2f88c2f7.js"><link rel="prefetch" href="/blog/assets/js/158.3b35883a.js"><link rel="prefetch" href="/blog/assets/js/159.de288906.js"><link rel="prefetch" href="/blog/assets/js/16.4069cf12.js"><link rel="prefetch" href="/blog/assets/js/160.e7f234cc.js"><link rel="prefetch" href="/blog/assets/js/161.bca72816.js"><link rel="prefetch" href="/blog/assets/js/162.d8d3eed1.js"><link rel="prefetch" href="/blog/assets/js/163.a1bca143.js"><link rel="prefetch" href="/blog/assets/js/164.ff04abf6.js"><link rel="prefetch" href="/blog/assets/js/165.d3847fc8.js"><link rel="prefetch" href="/blog/assets/js/166.24244820.js"><link rel="prefetch" href="/blog/assets/js/167.cd80c500.js"><link rel="prefetch" href="/blog/assets/js/168.c29d9d1e.js"><link rel="prefetch" href="/blog/assets/js/169.a3a8cc06.js"><link rel="prefetch" href="/blog/assets/js/17.79bd023c.js"><link rel="prefetch" href="/blog/assets/js/170.08cf1ef4.js"><link rel="prefetch" href="/blog/assets/js/171.63c3135c.js"><link rel="prefetch" href="/blog/assets/js/172.82b1bce8.js"><link rel="prefetch" href="/blog/assets/js/173.71cd38d6.js"><link rel="prefetch" href="/blog/assets/js/174.b9ea578c.js"><link rel="prefetch" href="/blog/assets/js/175.370c4bd0.js"><link rel="prefetch" href="/blog/assets/js/176.b14d6831.js"><link rel="prefetch" href="/blog/assets/js/177.0352635e.js"><link rel="prefetch" href="/blog/assets/js/178.3cdb1800.js"><link rel="prefetch" href="/blog/assets/js/179.9b8c1733.js"><link rel="prefetch" href="/blog/assets/js/18.019a7c67.js"><link rel="prefetch" href="/blog/assets/js/180.ab553d9e.js"><link rel="prefetch" href="/blog/assets/js/181.4ca9ae6f.js"><link rel="prefetch" href="/blog/assets/js/182.5b8c95b5.js"><link rel="prefetch" href="/blog/assets/js/183.fbf20d93.js"><link rel="prefetch" href="/blog/assets/js/184.bae10e54.js"><link rel="prefetch" href="/blog/assets/js/185.d3dc237f.js"><link rel="prefetch" href="/blog/assets/js/186.9f341504.js"><link rel="prefetch" href="/blog/assets/js/187.80e71c52.js"><link rel="prefetch" href="/blog/assets/js/188.1530f52d.js"><link rel="prefetch" href="/blog/assets/js/189.fe92e468.js"><link rel="prefetch" href="/blog/assets/js/19.7c15232c.js"><link rel="prefetch" href="/blog/assets/js/190.6c2b8606.js"><link rel="prefetch" href="/blog/assets/js/191.d982f777.js"><link rel="prefetch" href="/blog/assets/js/192.a9fd1fa8.js"><link rel="prefetch" href="/blog/assets/js/193.b57cf720.js"><link rel="prefetch" href="/blog/assets/js/194.8290160e.js"><link rel="prefetch" href="/blog/assets/js/195.48b0c331.js"><link rel="prefetch" href="/blog/assets/js/196.8b4f8598.js"><link rel="prefetch" href="/blog/assets/js/197.c6674dc8.js"><link rel="prefetch" href="/blog/assets/js/198.898105ea.js"><link rel="prefetch" href="/blog/assets/js/199.20a695b6.js"><link rel="prefetch" href="/blog/assets/js/20.becddea5.js"><link rel="prefetch" href="/blog/assets/js/200.3a276c3c.js"><link rel="prefetch" href="/blog/assets/js/201.ebe7ef57.js"><link rel="prefetch" href="/blog/assets/js/202.ef56e8b8.js"><link rel="prefetch" href="/blog/assets/js/203.a859f5f4.js"><link rel="prefetch" href="/blog/assets/js/204.521014d1.js"><link rel="prefetch" href="/blog/assets/js/205.65f93b9e.js"><link rel="prefetch" href="/blog/assets/js/206.30550734.js"><link rel="prefetch" href="/blog/assets/js/207.ba12be14.js"><link rel="prefetch" href="/blog/assets/js/208.cd4b31f0.js"><link rel="prefetch" href="/blog/assets/js/209.5a0e2a72.js"><link rel="prefetch" href="/blog/assets/js/21.2abc4662.js"><link rel="prefetch" href="/blog/assets/js/210.aade8a85.js"><link rel="prefetch" href="/blog/assets/js/211.4e7947bc.js"><link rel="prefetch" href="/blog/assets/js/212.13611c18.js"><link rel="prefetch" href="/blog/assets/js/213.d441e126.js"><link rel="prefetch" href="/blog/assets/js/214.d3bbee16.js"><link rel="prefetch" href="/blog/assets/js/215.0d3767e7.js"><link rel="prefetch" href="/blog/assets/js/216.446b2a83.js"><link rel="prefetch" href="/blog/assets/js/217.4702fdea.js"><link rel="prefetch" href="/blog/assets/js/218.555b4d64.js"><link rel="prefetch" href="/blog/assets/js/219.188b76ba.js"><link rel="prefetch" href="/blog/assets/js/22.4c778411.js"><link rel="prefetch" href="/blog/assets/js/220.ebcde46f.js"><link rel="prefetch" href="/blog/assets/js/221.b93a679f.js"><link rel="prefetch" href="/blog/assets/js/222.3c8e2f17.js"><link rel="prefetch" href="/blog/assets/js/223.e286d530.js"><link rel="prefetch" href="/blog/assets/js/224.402e47ee.js"><link rel="prefetch" href="/blog/assets/js/225.7de33b3e.js"><link rel="prefetch" href="/blog/assets/js/226.6bc2603d.js"><link rel="prefetch" href="/blog/assets/js/227.9c14cf2b.js"><link rel="prefetch" href="/blog/assets/js/228.ebfd1bbd.js"><link rel="prefetch" href="/blog/assets/js/229.794e50e0.js"><link rel="prefetch" href="/blog/assets/js/23.3adf2e7b.js"><link rel="prefetch" href="/blog/assets/js/230.e224cdfc.js"><link rel="prefetch" href="/blog/assets/js/231.cf4bd793.js"><link rel="prefetch" href="/blog/assets/js/232.4963c527.js"><link rel="prefetch" href="/blog/assets/js/233.3742c18e.js"><link rel="prefetch" href="/blog/assets/js/234.f6f02f99.js"><link rel="prefetch" href="/blog/assets/js/235.879bddf3.js"><link rel="prefetch" href="/blog/assets/js/236.7a243bc2.js"><link rel="prefetch" href="/blog/assets/js/237.f098433f.js"><link rel="prefetch" href="/blog/assets/js/238.a34d9086.js"><link rel="prefetch" href="/blog/assets/js/239.b753ca30.js"><link rel="prefetch" href="/blog/assets/js/24.33be9616.js"><link rel="prefetch" href="/blog/assets/js/240.08f3a81e.js"><link rel="prefetch" href="/blog/assets/js/241.822c23a9.js"><link rel="prefetch" href="/blog/assets/js/242.abc62596.js"><link rel="prefetch" href="/blog/assets/js/243.6ceb7603.js"><link rel="prefetch" href="/blog/assets/js/244.9b38110b.js"><link rel="prefetch" href="/blog/assets/js/245.5ce12f04.js"><link rel="prefetch" href="/blog/assets/js/246.6349dd16.js"><link rel="prefetch" href="/blog/assets/js/247.75457cb2.js"><link rel="prefetch" href="/blog/assets/js/248.8704a9bc.js"><link rel="prefetch" href="/blog/assets/js/249.69874bf9.js"><link rel="prefetch" href="/blog/assets/js/25.0877e4ef.js"><link rel="prefetch" href="/blog/assets/js/250.499b6d2b.js"><link rel="prefetch" href="/blog/assets/js/251.d6cdcca1.js"><link rel="prefetch" href="/blog/assets/js/252.b234b9dd.js"><link rel="prefetch" href="/blog/assets/js/253.ff32fe13.js"><link rel="prefetch" href="/blog/assets/js/254.c4bd6fee.js"><link rel="prefetch" href="/blog/assets/js/255.e971ca96.js"><link rel="prefetch" href="/blog/assets/js/256.f2261424.js"><link rel="prefetch" href="/blog/assets/js/257.9f97bfde.js"><link rel="prefetch" href="/blog/assets/js/258.12589bdf.js"><link rel="prefetch" href="/blog/assets/js/259.5e8d7f09.js"><link rel="prefetch" href="/blog/assets/js/26.0284307b.js"><link rel="prefetch" href="/blog/assets/js/260.bb25a24c.js"><link rel="prefetch" href="/blog/assets/js/261.2af3b275.js"><link rel="prefetch" href="/blog/assets/js/262.81139fd9.js"><link rel="prefetch" href="/blog/assets/js/263.10339da2.js"><link rel="prefetch" href="/blog/assets/js/264.52525e48.js"><link rel="prefetch" href="/blog/assets/js/265.036afaa7.js"><link rel="prefetch" href="/blog/assets/js/266.0880b02e.js"><link rel="prefetch" href="/blog/assets/js/267.bb19f83d.js"><link rel="prefetch" href="/blog/assets/js/268.b81c5554.js"><link rel="prefetch" href="/blog/assets/js/269.58119514.js"><link rel="prefetch" href="/blog/assets/js/27.7cf8264e.js"><link rel="prefetch" href="/blog/assets/js/270.67488264.js"><link rel="prefetch" href="/blog/assets/js/271.48cf3e3c.js"><link rel="prefetch" href="/blog/assets/js/272.02fe0ae4.js"><link rel="prefetch" href="/blog/assets/js/273.3746215f.js"><link rel="prefetch" href="/blog/assets/js/274.d72924ae.js"><link rel="prefetch" href="/blog/assets/js/275.75224fc7.js"><link rel="prefetch" href="/blog/assets/js/276.3f3ddaa2.js"><link rel="prefetch" href="/blog/assets/js/277.0ea0d1af.js"><link rel="prefetch" href="/blog/assets/js/28.b8e6d6c7.js"><link rel="prefetch" href="/blog/assets/js/29.067316a4.js"><link rel="prefetch" href="/blog/assets/js/3.078209c2.js"><link rel="prefetch" href="/blog/assets/js/30.159abf4f.js"><link rel="prefetch" href="/blog/assets/js/31.d922fcf9.js"><link rel="prefetch" href="/blog/assets/js/32.f9c7ca4c.js"><link rel="prefetch" href="/blog/assets/js/33.bdad240e.js"><link rel="prefetch" href="/blog/assets/js/34.f2bbc2d1.js"><link rel="prefetch" href="/blog/assets/js/35.bc2c25c1.js"><link rel="prefetch" href="/blog/assets/js/36.01853d6b.js"><link rel="prefetch" href="/blog/assets/js/38.8afeb2de.js"><link rel="prefetch" href="/blog/assets/js/39.cfdb7b3e.js"><link rel="prefetch" href="/blog/assets/js/4.8fe7a186.js"><link rel="prefetch" href="/blog/assets/js/40.19c78f35.js"><link rel="prefetch" href="/blog/assets/js/41.54cd742c.js"><link rel="prefetch" href="/blog/assets/js/42.5b417e50.js"><link rel="prefetch" href="/blog/assets/js/43.f03b86b8.js"><link rel="prefetch" href="/blog/assets/js/44.b7113dba.js"><link rel="prefetch" href="/blog/assets/js/45.3fdc56bd.js"><link rel="prefetch" href="/blog/assets/js/46.a90ddf9f.js"><link rel="prefetch" href="/blog/assets/js/47.e1c53a3e.js"><link rel="prefetch" href="/blog/assets/js/48.647bfea7.js"><link rel="prefetch" href="/blog/assets/js/49.96a3c8bc.js"><link rel="prefetch" href="/blog/assets/js/5.5967bee8.js"><link rel="prefetch" href="/blog/assets/js/50.26f0357e.js"><link rel="prefetch" href="/blog/assets/js/51.da90b3f8.js"><link rel="prefetch" href="/blog/assets/js/52.5882479e.js"><link rel="prefetch" href="/blog/assets/js/53.3713556c.js"><link rel="prefetch" href="/blog/assets/js/54.101160d6.js"><link rel="prefetch" href="/blog/assets/js/55.54118f32.js"><link rel="prefetch" href="/blog/assets/js/56.d2fa3572.js"><link rel="prefetch" href="/blog/assets/js/57.7725704f.js"><link rel="prefetch" href="/blog/assets/js/58.c033cc7f.js"><link rel="prefetch" href="/blog/assets/js/59.b7daeca5.js"><link rel="prefetch" href="/blog/assets/js/6.17dcb484.js"><link rel="prefetch" href="/blog/assets/js/60.d9d701aa.js"><link rel="prefetch" href="/blog/assets/js/61.2fa38130.js"><link rel="prefetch" href="/blog/assets/js/62.47dfde10.js"><link rel="prefetch" href="/blog/assets/js/63.a5c3c884.js"><link rel="prefetch" href="/blog/assets/js/64.8e4cdd51.js"><link rel="prefetch" href="/blog/assets/js/65.5a88727c.js"><link rel="prefetch" href="/blog/assets/js/66.5408ab41.js"><link rel="prefetch" href="/blog/assets/js/67.d01a2247.js"><link rel="prefetch" href="/blog/assets/js/68.221079cf.js"><link rel="prefetch" href="/blog/assets/js/69.5e64e3f0.js"><link rel="prefetch" href="/blog/assets/js/7.28c1da78.js"><link rel="prefetch" href="/blog/assets/js/70.1879d3dd.js"><link rel="prefetch" href="/blog/assets/js/71.eddb25f1.js"><link rel="prefetch" href="/blog/assets/js/72.37939565.js"><link rel="prefetch" href="/blog/assets/js/73.b892ade0.js"><link rel="prefetch" href="/blog/assets/js/74.bf1943d7.js"><link rel="prefetch" href="/blog/assets/js/75.04505cda.js"><link rel="prefetch" href="/blog/assets/js/76.83fd9cc3.js"><link rel="prefetch" href="/blog/assets/js/77.85cc78f2.js"><link rel="prefetch" href="/blog/assets/js/78.0374c2f3.js"><link rel="prefetch" href="/blog/assets/js/79.870e06b7.js"><link rel="prefetch" href="/blog/assets/js/80.b4d0f546.js"><link rel="prefetch" href="/blog/assets/js/81.6ccabcda.js"><link rel="prefetch" href="/blog/assets/js/82.b0eb7a5c.js"><link rel="prefetch" href="/blog/assets/js/83.98170b69.js"><link rel="prefetch" href="/blog/assets/js/84.21ce5c07.js"><link rel="prefetch" href="/blog/assets/js/85.aa0d4a14.js"><link rel="prefetch" href="/blog/assets/js/86.bd98fe6d.js"><link rel="prefetch" href="/blog/assets/js/87.ff3adcc3.js"><link rel="prefetch" href="/blog/assets/js/88.63f50c78.js"><link rel="prefetch" href="/blog/assets/js/89.77ed0897.js"><link rel="prefetch" href="/blog/assets/js/90.ef85ae84.js"><link rel="prefetch" href="/blog/assets/js/91.c1f0345a.js"><link rel="prefetch" href="/blog/assets/js/92.a285556a.js"><link rel="prefetch" href="/blog/assets/js/93.fd3a77d4.js"><link rel="prefetch" href="/blog/assets/js/94.c8527a0b.js"><link rel="prefetch" href="/blog/assets/js/95.f679cc1f.js"><link rel="prefetch" href="/blog/assets/js/96.f8bcd9cf.js"><link rel="prefetch" href="/blog/assets/js/97.3bd51540.js"><link rel="prefetch" href="/blog/assets/js/98.c69ee606.js"><link rel="prefetch" href="/blog/assets/js/99.235adf16.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.34249538.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.3b23bb34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端WebGL</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/articles/webgl/" class="nav-link">
  图形学
</a></div><div class="nav-item"><a href="/blog/articles/threejs/" class="nav-link">
  threejs
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/articles/webgl/" class="nav-link">
  图形学
</a></div><div class="nav-item"><a href="/blog/articles/threejs/" class="nav-link">
  threejs
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/articles/%E7%AE%97%E6%B3%95/" aria-current="page" class="sidebar-link">算法之排序</a></li><li><a href="/blog/articles/算法/leetcode之动态规划专题.html" class="sidebar-link">leetcode之动态规划专题</a></li><li><a href="/blog/articles/算法/leetCode之广度优先搜索专题.html" class="sidebar-link">leetCode之广度优先搜索题目总结</a></li><li><a href="/blog/articles/算法/leetcode之数组连续递增序列题目总结.html" class="sidebar-link">leetcode之数组连续递增序列题目总结</a></li><li><a href="/blog/articles/算法/leetcode之树专题.html" class="active sidebar-link">leetcode之树专题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_1、树的层序遍历从上到下打印二叉树-ii" class="sidebar-link">1、树的层序遍历从上到下打印二叉树 II</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_2、树的层序遍历2-ii-从上到下打印二叉树-ii" class="sidebar-link">2、树的层序遍历2——II. 从上到下打印二叉树 II</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_3、前序遍历二叉树的深度" class="sidebar-link">3、前序遍历二叉树的深度</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_4、前序遍历-二叉树的镜像" class="sidebar-link">4、前序遍历 二叉树的镜像</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_5、前序遍历求根到叶子节点数字之和" class="sidebar-link">5、前序遍历求根到叶子节点数字之和</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_6、前序遍历对称的二叉树" class="sidebar-link">6、前序遍历对称的二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_7、前序遍历平衡二叉树" class="sidebar-link">7、前序遍历平衡二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_8、二叉搜索树的最近公共祖先" class="sidebar-link">8、二叉搜索树的最近公共祖先</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_9、路径总和" class="sidebar-link">9、路径总和</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_10、二叉搜索树的最近公共祖先" class="sidebar-link">10、二叉搜索树的最近公共祖先</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_11、中序遍历-二叉搜索树的最小绝对差" class="sidebar-link">11、中序遍历 二叉搜索树的最小绝对差</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_12、前序遍历左叶子之和" class="sidebar-link">12、前序遍历左叶子之和</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_13、前序遍历单值二叉树" class="sidebar-link">13、前序遍历单值二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_14、层序遍历-广度优先遍历-二叉树的层平均值" class="sidebar-link">14、层序遍历(广度优先遍历) 二叉树的层平均值</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_15、层序遍历-广度优先遍历-n叉树的最大深度" class="sidebar-link">15、层序遍历(广度优先遍历)N叉树的最大深度</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_16、前序遍历-深度优先遍历-二叉树的直径" class="sidebar-link">16、前序遍历(深度优先遍历) 二叉树的直径</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_17、前序遍历二叉树中第二小的节点" class="sidebar-link">17、前序遍历二叉树中第二小的节点</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_18-、前序遍历-二叉树的堂兄弟节点" class="sidebar-link">18 、前序遍历 二叉树的堂兄弟节点</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_19、前序遍历-dfs-求和路径" class="sidebar-link">19、前序遍历(dfs)求和路径</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_20、修剪二叉搜索树" class="sidebar-link">20、修剪二叉搜索树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_24、二叉树的最小深度" class="sidebar-link">24、二叉树的最小深度</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_21、-后续遍历-好叶子节点对的数量" class="sidebar-link">21、[后续遍历]好叶子节点对的数量</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_22、树的子结构" class="sidebar-link">22、树的子结构</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_30、具有所有最深节点的最小子树" class="sidebar-link">30、具有所有最深节点的最小子树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_31、从前序和中序遍历序列构造二叉树" class="sidebar-link">31、从前序和中序遍历序列构造二叉树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_32、将有序数组转换为二叉搜索树" class="sidebar-link">32、将有序数组转换为二叉搜索树</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_33、二叉树的坡度" class="sidebar-link">33、二叉树的坡度</a></li><li class="sidebar-sub-header"><a href="/blog/articles/算法/leetcode之树专题.html#_34、另一颗树的子树" class="sidebar-link">34、另一颗树的子树</a></li></ul></li><li><a href="/blog/articles/算法/leetcode之递归专题.html" class="sidebar-link">leetcode之递归专题</a></li><li><a href="/blog/articles/算法/leetcode之链表专题.html" class="sidebar-link">leetcode之链表专题</a></li><li><a href="/blog/articles/算法/动态规划之背包问题总结.html" class="sidebar-link">动态规划之背包问题总结</a></li><li><a href="/blog/articles/算法/数据结构之图.html" class="sidebar-link">数据结构之图</a></li><li><a href="/blog/articles/算法/数据结构之堆.html" class="sidebar-link">数据结构之堆</a></li><li><a href="/blog/articles/算法/数据结构之字符串总结.html" class="sidebar-link">数据结构之字符串总结</a></li><li><a href="/blog/articles/算法/数据结构之树.html" class="sidebar-link">数据结构之树的基础知识</a></li><li><a href="/blog/articles/算法/数据结构和算法基础知识总结.html" class="sidebar-link">数据结构和算法基础知识总结</a></li><li><a href="/blog/articles/算法/算法之查找.html" class="sidebar-link">算法之查找</a></li><li><a href="/blog/articles/算法/算法基本思想之分治算法.html" class="sidebar-link">算法基本思想之分治算法</a></li><li><a href="/blog/articles/算法/算法基本思想之动态规划.html" class="sidebar-link">算法基本思想之动态规划</a></li><li><a href="/blog/articles/算法/算法基本思想之回溯算法.html" class="sidebar-link">算法基本思想之回溯算法</a></li><li><a href="/blog/articles/算法/算法基本思想之贪心算法.html" class="sidebar-link">算法基本思想之贪心算法</a></li><li><a href="/blog/articles/算法/遍历之深度优先遍历和广度优先遍历的区别 .html" class="sidebar-link">广度和深度优先遍历</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1、树的层序遍历从上到下打印二叉树-ii"><a href="#_1、树的层序遍历从上到下打印二叉树-ii" class="header-anchor">#</a> 1、树的层序遍历<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener noreferrer">从上到下打印二叉树 II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
**解题思路:**利用栈来存储结点。每次遍历时，将当前结点的左右结点入栈，循环时依次出栈。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token comment">//层序遍历 利用栈来存储节点</span>
<span class="token keyword">function</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nodeQueue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> curNode<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>nodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        curNode<span class="token operator">=</span>nodeQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        curNode<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span>nodeQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        curNode<span class="token punctuation">.</span>right<span class="token operator">&amp;&amp;</span>nodeQUeue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_2、树的层序遍历2-ii-从上到下打印二叉树-ii"><a href="#_2、树的层序遍历2-ii-从上到下打印二叉树-ii" class="header-anchor">#</a> 2、树的层序遍历2——<a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/" target="_blank" rel="noopener noreferrer">II. 从上到下打印二叉树 II<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[][]}
 */</span>
<span class="token comment">//层序遍历</span>
<span class="token keyword">function</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nodeQueue<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> level<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>curNode<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span>levelNodeNum<span class="token punctuation">;</span>
    <span class="token comment">//表示有多少层</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>nodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        levelNodeNum<span class="token operator">=</span>nodeQueue<span class="token punctuation">.</span>length<span class="token punctuation">;</span><span class="token comment">//第level层的节点个数</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>levelNodeNum<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            curNode<span class="token operator">=</span>nodeQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            curNode<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span>nodeQueue<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            curNode<span class="token punctuation">.</span>right<span class="token operator">&amp;&amp;</span>nodeQueue<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        level<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_3、前序遍历二叉树的深度"><a href="#_3、前序遍历二叉树的深度" class="header-anchor">#</a> 3、前序遍历<a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/submissions/" target="_blank" rel="noopener noreferrer">二叉树的深度<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
<strong>解题思路：</strong> 递归比较左右支树的深度，每次递归时深度加1.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">//获当前左右子树的深度的较大值 并且+1</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_4、前序遍历-二叉树的镜像"><a href="#_4、前序遍历-二叉树的镜像" class="header-anchor">#</a> 4、前序遍历<a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener noreferrer"> 二叉树的镜像<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。
<strong>解题思路：</strong> 递归遍历整棵树,在递归时交换左右结点的位置。本质上是前序遍历。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */</span>
<span class="token keyword">function</span> <span class="token function">mirrorTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">function</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">//前序遍历 跟左右</span>
        <span class="token comment">//交换左右节点的位置</span>
        <span class="token keyword">const</span> tempNode<span class="token operator">=</span>node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right<span class="token operator">=</span>tempNode<span class="token punctuation">;</span>
        <span class="token comment">//递归左右节点</span>
        <span class="token function">levelOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">levelOrder</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">levelOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_5、前序遍历求根到叶子节点数字之和"><a href="#_5、前序遍历求根到叶子节点数字之和" class="header-anchor">#</a> 5、前序遍历<a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener noreferrer">求根到叶子节点数字之和<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。
计算从根到叶子节点生成的所有数字之和。
<strong>说明:</strong> 叶子节点是指没有子节点的节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token keyword">function</span> <span class="token function">sumNumbers</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>sum</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//表示该叶子节点不存在,则返回0</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//树深度每加深一层，sum乘以10再加上当前节点的值</span>
        sum<span class="token operator">=</span>sum<span class="token operator">*</span><span class="token number">10</span><span class="token operator">+</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//没有叶子节点了</span>
            <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token operator">+</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_6、前序遍历对称的二叉树"><a href="#_6、前序遍历对称的二叉树" class="header-anchor">#</a> 6、前序遍历<a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener noreferrer">对称的二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1
/ <br>
2   2
/ \ / <br>
3  4 4  3</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">symmetricTree</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> root<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">?</span><span class="token boolean">true</span><span class="token operator">:</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token parameter">l<span class="token punctuation">,</span>r</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//没有左右节点的情况</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">&amp;&amp;</span>r<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token comment">/*
         * 情况1 l=null,r!=null 
         * 情况2 l!=null,r===null
         * 情况3 l!=null,r!=null l.val!=r.val
         */</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>r<span class="token operator">===</span><span class="token keyword">null</span><span class="token operator">||</span>l<span class="token punctuation">.</span>val<span class="token operator">!==</span>r<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">//递归左右子节点</span>
        <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>left<span class="token punctuation">,</span>r<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">dfs</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span>right<span class="token punctuation">,</span>r<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_7、前序遍历平衡二叉树"><a href="#_7、前序遍历平衡二叉树" class="header-anchor">#</a> 7、前序遍历<a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/" target="_blank" rel="noopener noreferrer">平衡二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
<strong>示例 1:</strong>
给定二叉树 [3,9,20,null,null,15,7]
3
/ <br>
9  20
/  <br>
15   7
返回 true 。
<strong>示例 2:</strong>
给定二叉树 [1,2,2,3,3,null,null,4,4]</p> <div class="language- extra-class"><pre><code>   1
  / \
 2   2
/ \
</code></pre></div><p>3   3
/ <br>
4   4
返回 false 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token operator">!==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//深度递归</span>
    <span class="token keyword">function</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//左子树的深度</span>
        <span class="token keyword">const</span> left<span class="token operator">=</span><span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//右子树的深度</span>
        <span class="token keyword">const</span> right<span class="token operator">=</span><span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//当节点root 左 / 右子树的深度差 \leq 1≤1 ：则返回当前子树的深度，</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>left<span class="token operator">-</span>right<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">?</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_8、二叉搜索树的最近公共祖先"><a href="#_8、二叉搜索树的最近公共祖先" class="header-anchor">#</a> 8、<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/" target="_blank" rel="noopener noreferrer">二叉搜索树的最近公共祖先<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p><strong>二叉搜索树具有以下性质</strong>:若它的左子树不为空，则左树上所有结点的值均小于它的根节点的值;若它右子树不为空，则右子树上所有结点的值均大于它的根节点的值；它的左、右子树也分别为二叉搜索树。
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p> <p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p> <p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
<img src="data:image/png;base64,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">
示例 1:</p> <p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
示例 2:</p> <p>输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span>q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">===</span>q<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//根据题目条件 要么p,q在同侧，要么再异侧。在同侧则则p或q的值对应的结点是祖先结点，在异侧则根节点是它们的最近公共祖先。</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//根值大于给定值，则它的根植只可能在右边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>right
        <span class="token punctuation">}</span>
        <span class="token comment">//根值大于给定值，则它的根植只可能在左边</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> q <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&gt;</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            root <span class="token operator">=</span> root<span class="token punctuation">.</span>left
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//p,q在异侧</span>
            <span class="token keyword">return</span> root
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_9、路径总和"><a href="#_9、路径总和" class="header-anchor">#</a> 9、<a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener noreferrer">路径总和<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。
示例:
给定如下二叉树，以及目标和 sum = 22，
5
/ <br>
4   8
/   / <br>
11  13  4
/  \      <br>
7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//方法 1 广度优先遍历</span>
<span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>sum</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> queueNode<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存结点</span>
    <span class="token keyword">const</span> queueVal<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//存结点和</span>
    <span class="token keyword">let</span> tempNode<span class="token punctuation">,</span>tempVal<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queueVal<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        tempNode<span class="token operator">=</span>queueNode<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前结点</span>
        tempVal<span class="token operator">=</span>queueVal<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//当前结点对应的根节点到当前结点的路径和</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>tempNode<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>tempNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>tempVal<span class="token operator">===</span>sum<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            queueNode<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queueVal<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempVal<span class="token operator">+</span>tempNode<span class="token punctuation">.</span>left<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            queueNode<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
            queueVal<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempVal<span class="token operator">+</span> tempNode<span class="token punctuation">.</span>right<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//方法 2 深度优先遍历</span>
<span class="token keyword">function</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>sum</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//表示该结点是空节点 此时sum的值肯定不等于它父节点的值，所以返回false</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">//表示当前结点是叶子结点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> root<span class="token punctuation">.</span>val<span class="token operator">===</span>sum<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//先深度递归左子树</span>
    <span class="token keyword">return</span> <span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">hasPathSum</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>sum<span class="token operator">-</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_10、二叉搜索树的最近公共祖先"><a href="#_10、二叉搜索树的最近公共祖先" class="header-anchor">#</a> 10、<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree" target="_blank" rel="noopener noreferrer">二叉搜索树的最近公共祖先<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：&quot;对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。&quot;
例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
<img src="data:image/png;base64,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"></p> <div class="language-js extra-class"><pre class="language-js"><code>示例 <span class="token number">1</span><span class="token operator">:</span>
<span class="token literal-property property">输入</span><span class="token operator">:</span> root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">8</span>
<span class="token literal-property property">输出</span><span class="token operator">:</span> <span class="token number">6</span> 
<span class="token literal-property property">解释</span><span class="token operator">:</span> 节点 <span class="token number">2</span> 和节点 <span class="token number">8</span> 的最近公共祖先是 <span class="token number">6</span>。
示例 <span class="token number">2</span><span class="token operator">:</span>
<span class="token literal-property property">输入</span><span class="token operator">:</span> root <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> q <span class="token operator">=</span> <span class="token number">4</span>
<span class="token literal-property property">输出</span><span class="token operator">:</span> <span class="token number">2</span>
<span class="token literal-property property">解释</span><span class="token operator">:</span> 节点 <span class="token number">2</span> 和节点 <span class="token number">4</span> 的最近公共祖先是 <span class="token number">2</span><span class="token punctuation">,</span> 因为根据定义最近公共祖先节点可以为节点本身。
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */</span>
<span class="token comment">//迭代法</span>
<span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> node<span class="token operator">=</span>root<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>p<span class="token punctuation">.</span>val<span class="token operator">&amp;&amp;</span>node<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            node<span class="token operator">=</span>node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>node<span class="token punctuation">.</span>val<span class="token operator">&amp;&amp;</span>q<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
            node<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 递归 </span>
<span class="token keyword">function</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> val<span class="token operator">=</span>root<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token operator">-</span>val<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token punctuation">.</span>val<span class="token operator">-</span>val<span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>p<span class="token punctuation">,</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_11、中序遍历-二叉搜索树的最小绝对差"><a href="#_11、中序遍历-二叉搜索树的最小绝对差" class="header-anchor">#</a> 11、中序遍历<a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener noreferrer"> 二叉搜索树的最小绝对差<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">getMinimumDifference</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//因为是二叉搜索树，所以任意两节点的差的最小值。肯定是两个相邻节点差的最小值。</span>
    <span class="token comment">//中序遍历来遍历二叉搜索树，前一个值总是大于后面一个值</span>
    <span class="token keyword">let</span> prevValue<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>res<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">//中序遍历 左根右</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>prevValue<span class="token operator">!==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//比较当前值与前一个值根的差与上一个最小差的大小</span>
            res<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>node<span class="token punctuation">.</span>val<span class="token operator">-</span>prevValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prevValue<span class="token operator">=</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_12、前序遍历左叶子之和"><a href="#_12、前序遍历左叶子之和" class="header-anchor">#</a> 12、前序遍历<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener noreferrer">左叶子之和<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">sumOfLeftLeaves</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">/**
     * @param {TreeNode} node
     * @return {boolean} flag 用于标识是否是左子节点
     */</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>flag</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token comment">//前序遍历</span>
        <span class="token comment">//判断是否是左子节点</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> res<span class="token operator">+=</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_13、前序遍历单值二叉树"><a href="#_13、前序遍历单值二叉树" class="header-anchor">#</a> 13、前序遍历<a href="https://leetcode-cn.com/problems/univalued-binary-tree/" target="_blank" rel="noopener noreferrer">单值二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。
只有给定的树是单值二叉树时，才返回 <code>true</code>；否则返回 <code>false</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {boolean}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isUnivalTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> prevValue<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>prevValue<span class="token operator">!==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//判断当前节点的值根上一个节点的值是否相等</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>prevValue<span class="token operator">!==</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        prevValue<span class="token operator">=</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token comment">//前序遍历(根左右) 先遍历左子树，后遍历右子树</span>
        <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span> <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_14、层序遍历-广度优先遍历-二叉树的层平均值"><a href="#_14、层序遍历-广度优先遍历-二叉树的层平均值" class="header-anchor">#</a> 14、层序遍历(广度优先遍历)<a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener noreferrer"> 二叉树的层平均值<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">averageOfLevels</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">const</span> res<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> queueNode<span class="token operator">=</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum<span class="token punctuation">,</span>levelNum<span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>queueNode<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>
        levelNum<span class="token operator">=</span>queueNode<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>levelNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>levelNum<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">const</span> tempNode<span class="token operator">=</span>queueNode<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            sum<span class="token operator">+=</span>tempNode<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
            tempNode<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span>queueNode<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
            tempNode<span class="token punctuation">.</span>right<span class="token operator">&amp;&amp;</span>queueNode<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>tempNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sum<span class="token operator">/</span>res<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_15、层序遍历-广度优先遍历-n叉树的最大深度"><a href="#_15、层序遍历-广度优先遍历-n叉树的最大深度" class="header-anchor">#</a> 15、层序遍历(广度优先遍历)<a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener noreferrer">N叉树的最大深度<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
例如，给定一个 3叉树 :
<img src="/blog/assets/img/narytreeexample.c0764c3d.png">
我们应返回其最大深度，3。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>depth</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> depth<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token operator">&amp;&amp;</span>node<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>          
            <span class="token keyword">return</span>  Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token operator">...</span>node<span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">children</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>children<span class="token punctuation">,</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
       
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_16、前序遍历-深度优先遍历-二叉树的直径"><a href="#_16、前序遍历-深度优先遍历-二叉树的直径" class="header-anchor">#</a> 16、前序遍历(深度优先遍历)<a href="%E7%BB%99%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E8%AE%A1%E7%AE%97%E5%AE%83%E7%9A%84%E7%9B%B4%E5%BE%84%E9%95%BF%E5%BA%A6%E3%80%82%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%E9%95%BF%E5%BA%A6%E6%98%AF%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%82%E8%BF%99%E6%9D%A1%E8%B7%AF%E5%BE%84%E5%8F%AF%E8%83%BD%E7%A9%BF%E8%BF%87%E4%B9%9F%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%A9%BF%E8%BF%87%E6%A0%B9%E7%BB%93%E7%82%B9%E3%80%82"> 二叉树的直径</a></h2> <p>示例 :
给定二叉树
1
/ <br>
2   3
/ \<br>
4   5<br>
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
<strong>注意：两结点之间的路径长度是以它们之间边的数目表示。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token comment">//这道题其实是一道求树中最长路径的问题</span>
<span class="token comment">//而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</span>
<span class="token keyword">var</span> <span class="token function-variable function">diameterOfBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//该结点不存在,返回0</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> Ldepth<span class="token operator">=</span><span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> Rdepth<span class="token operator">=</span><span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//获取路径最大值</span>
        res<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>Ldepth<span class="token operator">+</span>Rdepth<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//每递归一次，深度+1;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Ldepth<span class="token punctuation">,</span>Rdepth<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_17、前序遍历二叉树中第二小的节点"><a href="#_17、前序遍历二叉树中第二小的节点" class="header-anchor">#</a> 17、前序遍历<a href="https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener noreferrer">二叉树中第二小的节点<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，<code>root.val = min(root.left.val, root.right.val)</code> 总成立。
给出这样的一个二叉树，你需要输出所有节点中的第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：</p> <img src="/blog/assets/img/smbt1.d88d11b7.jpg">
输入：root = [2,2,5,null,null,5,7]
输出：5
解释：最小的值是 2 ，第二小的值是 5 。
<div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @return {number}
 */</span>
<span class="token comment">//暴力法</span>
<span class="token keyword">var</span> <span class="token function-variable function">findSecondMinimumValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">...</span>res<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">||</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//方法 2 找规律</span>
<span class="token keyword">var</span> <span class="token function-variable function">findSecondMinimumValue</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>min</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">//根左右 判断当前结点跟最小值的关系</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>min<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        <span class="token comment">//遍历左子树 判断左子节点跟最小值的关系</span>
        <span class="token keyword">const</span> left<span class="token operator">=</span><span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//遍历右子树 判断左子节点跟最小值的关系</span>
        <span class="token keyword">const</span> right<span class="token operator">=</span><span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//没有左子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right<span class="token punctuation">;</span>
        <span class="token comment">//没有右子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">===</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_18-、前序遍历-二叉树的堂兄弟节点"><a href="#_18-、前序遍历-二叉树的堂兄弟节点" class="header-anchor">#</a> 18 、前序遍历<a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/" target="_blank" rel="noopener noreferrer"> 二叉树的堂兄弟节点<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>在二叉树中，根节点位于深度 0 处，每个深度为<code>k</code>的节点的子节点位于深度<code>k+1</code>处。如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。我们给出了具有唯一值的二叉树的根节点 <code>root</code>，以及树中两个不同节点的值 <code>x</code> 和<code>y</code>。只有与值 <code>x</code> 和 <code>y</code>对应的节点是堂兄弟节点时，才返回 <code>true</code>。否则，返回 <code>false</code>。
</p> <p>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isCousins</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * 1、他们父节点不同
     * 2、他们的深度一样
    */</span>
    <span class="token comment">//两个对象来存储当前结点的深度和父节点</span>
    <span class="token keyword">const</span> depthObj<span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">,</span>parentObj<span class="token operator">=</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recursive</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>parent</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        depthObj<span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token operator">=</span>parent<span class="token operator">?</span>depthObj<span class="token punctuation">[</span>parent<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>
        parentObj<span class="token punctuation">[</span>node<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token operator">=</span>parent<span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">recursive</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recursive</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> depthObj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">===</span>depthObj<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>parentObj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">!==</span>parentObj<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_19、前序遍历-dfs-求和路径"><a href="#_19、前序遍历-dfs-求和路径" class="header-anchor">#</a> 19、前序遍历(dfs)<a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/" target="_blank" rel="noopener noreferrer">求和路径<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>  给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
示例:
给定如下二叉树，以及目标和 sum = 22，</p> <div class="language- extra-class"><pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre></div><p>返回:3
解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">pathSum</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>sum</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">resolve</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>target</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token operator">===</span>target<span class="token punctuation">)</span> <span class="token keyword">return</span> res<span class="token operator">++</span><span class="token punctuation">;</span>
        res<span class="token operator">+=</span><span class="token function">resolve</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token operator">-</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res<span class="token operator">+=</span><span class="token function">resolve</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token operator">-</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>target</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment">//深度递归当前结点</span>
        res<span class="token operator">+=</span><span class="token function">resolve</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//深度递归左结点</span>
        res<span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//深度递归右结点</span>
        res<span class="token operator">+=</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_20、修剪二叉搜索树"><a href="#_20、修剪二叉搜索树" class="header-anchor">#</a> 20、<a href="https://leetcode-cn.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">修剪二叉搜索树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>  给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code>和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
<img src="/blog/assets/img/trim2.8ac04a2e.jpg">
示例 2：
输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
输出：[3,2,null,1]</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * @param {TreeNode} root
 * @param {number} low
 * @param {number} high
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">trimBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//返回当前结点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token comment">//当前结点的值大于最大值，那么它右子树上的所有值都会大于当前值，就不用再考虑</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">&gt;</span>high<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// //当前结点的值小于最小值，那么它左子树上的所有值都会大于当前值，就不用再考虑</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token operator">&lt;</span>low<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//递归当前结点的左子树之后的结果赋值给当前结点的左子树</span>
    root<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token comment">//递归当前结点的左子树之后的结果赋值给当前结点的左子树</span>
    root<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">trimBST</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_24、二叉树的最小深度"><a href="#_24、二叉树的最小深度" class="header-anchor">#</a> 24、<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/" target="_blank" rel="noopener noreferrer">二叉树的最小深度<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>  给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
说明：叶子节点是指没有子节点的节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//获取树的最小深度</span>
<span class="token keyword">const</span> <span class="token function-variable function">minDepth</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//没有左右节点 则当前节点的深度是1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> minValue<span class="token operator">=</span>Number<span class="token punctuation">.</span><span class="token constant">MAX_SAFE_INTEGER</span><span class="token punctuation">;</span>；
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            minValue<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minValue<span class="token punctuation">,</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            minValue<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minValue<span class="token punctuation">,</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> minValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//获取树的最大深度</span>
<span class="token keyword">const</span> <span class="token function-variable function">minDepth</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//没有左右节点 则当前节点的深度是1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> maxValue<span class="token operator">=</span>Number<span class="token punctuation">.</span><span class="token constant">MIN_SAFE_INTEGER</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">{</span>
            maxValue<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            maxValue<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> maxValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>=======</p> <h2 id="_21、-后续遍历-好叶子节点对的数量"><a href="#_21、-后续遍历-好叶子节点对的数量" class="header-anchor">#</a> 21、[后续遍历]<a href="https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/" target="_blank" rel="noopener noreferrer">好叶子节点对的数量<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>  给你二叉树的根节点 <code>root</code> 和一个整数 <code>distance</code> 。如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。返回树中 好叶子节点对的数量 。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">countPairs</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span>distance</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
   
    <span class="token keyword">let</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">// if(!node) return [];</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//存放当前结点各叶子结点离它的距离</span>
        <span class="token keyword">const</span> leaves<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//表示当前结点左结点各叶子结点离它的距离</span>
        <span class="token keyword">const</span> leftLeaves<span class="token operator">=</span>node<span class="token punctuation">.</span>left<span class="token operator">?</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//表示当前结点右结点各叶子结点离它的距离</span>
        <span class="token keyword">const</span> rightLeaves<span class="token operator">=</span>node<span class="token punctuation">.</span>right<span class="token operator">?</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        leftLeaves<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">leave</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>leave<span class="token operator">&lt;</span>distance<span class="token operator">&amp;&amp;</span>leaves<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leave<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        rightLeaves<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">leave</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
            <span class="token operator">++</span>leave<span class="token operator">&lt;</span>distance<span class="token operator">&amp;&amp;</span>leaves<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leave<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token comment">//判断当前结点左右结点叶子结点的距离跟distance的关系</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> leftLeaves<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token keyword">of</span> rightLeaves<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token operator">+</span><span class="token number">2</span><span class="token operator">&lt;=</span>distance<span class="token punctuation">)</span> res<span class="token operator">+=</span><span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> leaves<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_22、树的子结构"><a href="#_22、树的子结构" class="header-anchor">#</a> 22、<a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/" target="_blank" rel="noopener noreferrer">树的子结构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSubStructure</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//前序遍历</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter"><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span></span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//递归终止条件</span>
        <span class="token comment">//1、遍历到B的叶子结点了，此时B肯定是A的子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">B</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">//2、递归A的叶子结点了，但是还没递归到B的叶子结点，或者A,B结点此时都不是叶子结点，但是A的结点的值不等于B的结点的值,那么B不是A的子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">A</span><span class="token operator">||</span><span class="token constant">A</span><span class="token punctuation">.</span>val<span class="token operator">!==</span><span class="token constant">B</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token comment">//3、如果A的结点的值不等于B的结点的值，则继续递归遍历</span>
        <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">recur</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token operator">&amp;&amp;</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token function">recur</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>left<span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">isSubStructure</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span>right<span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_30、具有所有最深节点的最小子树"><a href="#_30、具有所有最深节点的最小子树" class="header-anchor">#</a> 30、<a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes/" target="_blank" rel="noopener noreferrer">具有所有最深节点的最小子树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//深度优先遍历</span>
<span class="token keyword">var</span> <span class="token function-variable function">lcaDeepestLeaves</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeDepth</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> leftObj<span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> rightObj<span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftObj<span class="token punctuation">.</span>depth<span class="token operator">&gt;</span>rightObj<span class="token punctuation">.</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//左结点对应的深度加1</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeDepth</span><span class="token punctuation">(</span>leftObj<span class="token punctuation">.</span>node<span class="token punctuation">,</span>leftObj<span class="token punctuation">.</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>leftObj<span class="token punctuation">.</span>depth<span class="token operator">&lt;</span>rightObj<span class="token punctuation">.</span>depth<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//右结点的深度加1</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeDepth</span><span class="token punctuation">(</span>rightObj<span class="token punctuation">.</span>node<span class="token punctuation">,</span>rightObj<span class="token punctuation">.</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNodeDepth</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>leftObj<span class="token punctuation">.</span>depth<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span>node<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">TreeNodeDepth</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>depth</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>node<span class="token operator">=</span>node<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>depth<span class="token operator">=</span>depth<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_31、从前序和中序遍历序列构造二叉树"><a href="#_31、从前序和中序遍历序列构造二叉树" class="header-anchor">#</a> 31、<a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">从前序和中序遍历序列构造二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <div class="language-js extra-class"><pre class="language-js"><code>
</code></pre></div><h2 id="_32、将有序数组转换为二叉搜索树"><a href="#_32、将有序数组转换为二叉搜索树" class="header-anchor">#</a> 32、<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">将有序数组转换为二叉搜索树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p> <p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//高度平衡二叉树 即左右子树的结点数差不多;</span>
<span class="token comment">//所以可以直接取有序数组的中间位置的数作为根节点,开始位置到中间位置的数组的为左子树，中间位置到结束位置的数组为右子树;</span>
<span class="token keyword">var</span> <span class="token function-variable function">sortedArrayToBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">num<span class="token punctuation">,</span>start<span class="token punctuation">,</span>end</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>start<span class="token operator">&gt;</span>end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> mid<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>start<span class="token operator">+</span>end<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> node<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>left<span class="token operator">=</span><span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>start<span class="token punctuation">,</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>right<span class="token operator">=</span><span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_33、二叉树的坡度"><a href="#_33、二叉树的坡度" class="header-anchor">#</a> 33、<a href="https://leetcode-cn.com/problems/binary-tree-tilt/" target="_blank" rel="noopener noreferrer">二叉树的坡度<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定一个二叉树，计算 整个树 的坡度 。</p> <p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p> <p>整个树 的坡度就是其所有节点的坡度之和。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">findTilt</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span>parent</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> leftVal<span class="token operator">=</span> <span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> rightVal<span class="token operator">=</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum<span class="token operator">+=</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>leftVal<span class="token operator">-</span>rightVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//当前结点对应的值=&gt; 左右结点的值+当前结点的值</span>
        <span class="token keyword">return</span> leftVal<span class="token operator">+</span>rightVal<span class="token operator">+</span>node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">recur</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_34、另一颗树的子树"><a href="#_34、另一颗树的子树" class="header-anchor">#</a> 34、<a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener noreferrer">另一颗树的子树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
下面这种情况是不成立的。
<strong>给定的树 s：</strong>
3
/ <br>
4   5
/ <br>
1   2
/
0
<strong>给定的树 t：</strong></p> <p>4
/ <br>
1   2
返回 false。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">isSubtree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span> t</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">check</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token parameter">s<span class="token punctuation">,</span>t</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token comment">//s和t都没有子节点了</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token operator">&amp;&amp;</span><span class="token operator">!</span>s<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">//一个有一个没有，或者两个都有，但是他们的值不等，那么t都不是s的子树</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token operator">||</span><span class="token operator">!</span>s<span class="token operator">||</span>t<span class="token punctuation">.</span>val<span class="token operator">!==</span>s<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>left<span class="token punctuation">,</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">&amp;&amp;</span><span class="token function">check</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>right<span class="token punctuation">,</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> <span class="token function-variable function">recur</span><span class="token operator">=</span><span class="token parameter">node</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> flag<span class="token punctuation">;</span>
        <span class="token comment">// //找到一个他们值相同的点</span>
        <span class="token comment">// if(node.val===t.val){</span>
        <span class="token comment">//     //判断他们是否相等</span>
        <span class="token comment">//     flag =check(node,t);</span>
        <span class="token comment">// }</span>
        <span class="token keyword">return</span> <span class="token function">check</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token operator">||</span> <span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">recur</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">recur</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/24/2024, 10:23:52 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/articles/算法/leetcode之数组连续递增序列题目总结.html" class="prev">
        leetcode之数组连续递增序列题目总结
      </a></span> <span class="next"><a href="/blog/articles/算法/leetcode之递归专题.html">
        leetcode之递归专题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.cc3037ec.js" defer></script><script src="/blog/assets/js/2.918eef7d.js" defer></script><script src="/blog/assets/js/1.dd66940c.js" defer></script><script src="/blog/assets/js/37.8fc3cb59.js" defer></script>
  </body>
</html>
